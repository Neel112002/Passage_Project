rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(ownerId) {
      return isAuthenticated() && request.auth.uid == ownerId;
    }

    // Chat helpers
    function chatDoc(chatId) {
      return get(/databases/$(database)/documents/chats/$(chatId));
    }
    function isChatMember(chatId) {
      return isAuthenticated() && request.auth.uid in chatDoc(chatId).data.members;
    }
    function validMembers(list) {
      return list is list && list.size() == 2 && list[0] is string && list[1] is string;
    }

    // Users collection - private (only owner can read/write their profile)
    match /users/{userId} {
      allow read, write: if isOwner(userId);
    }

    // Products collection - public read, admin write
    // For now, signed-in users can write (you can restrict this to admin-only later)
    match /products/{productId} {
      allow read: if true;
      allow write: if isAuthenticated();
    }

    // Orders collection - private (user can only see their own orders)
    match /orders/{orderId} {
      allow read, update, delete: if isAuthenticated() && request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
    }

    // Reviews collection - public read, signed-in write
    match /reviews/{reviewId} {
      allow read: if true;
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
      allow update, delete: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }

    // Cart items - private (user-specific sub-collection)
    match /users/{userId}/cart/{cartItemId} {
      allow read, write: if isOwner(userId);
    }

    // Addresses - private (user-specific sub-collection)
    match /users/{userId}/addresses/{addressId} {
      allow read, write: if isOwner(userId);
    }

    // Payment methods - private (user-specific sub-collection)
    match /users/{userId}/payment_methods/{paymentId} {
      allow read, write: if isOwner(userId);
    }

    // Notifications - private (user-specific sub-collection)
    match /users/{userId}/notifications/{notificationId} {
      allow read, write: if isOwner(userId);
    }

    // Seller accounts - for now, allow read/write to authenticated users
    // You can restrict this later based on your requirements
    match /sellers/{sellerId} {
      allow read, write: if isAuthenticated();
    }

    // Admin accounts - restrict to authenticated users
    match /admins/{adminId} {
      allow read, write: if isAuthenticated();
    }

    // Chats and messages â€” allow only chat members
    match /chats/{chatId} {
      // Members can read the chat document
      allow read: if isChatMember(chatId);

      // Create when the requester is one of the members and payload is well-formed
      allow create: if isAuthenticated()
        && validMembers(request.resource.data.members)
        && request.auth.uid in request.resource.data.members
        && request.resource.data.lastMessage is string
        && request.resource.data.lastSender is string
        && request.resource.data.productName is string
        && request.resource.data.productImageUrl is string
        && (request.resource.data.listingId == null || request.resource.data.listingId is string)
        && request.resource.data.updatedAt is timestamp;

      // Update allowed for members; members array must not change
      allow update: if isChatMember(chatId)
        && request.resource.data.members == resource.data.members
        && request.resource.data.updatedAt is timestamp;

      allow delete: if false;

      // Subcollection: messages
      match /messages/{messageId} {
        allow read: if isChatMember(chatId);
        allow create: if isChatMember(chatId)
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.senderId is string
          && request.resource.data.text is string
          && request.resource.data.imageUrl is string
          && request.resource.data.status is string
          && request.resource.data.createdAt is timestamp;
        // Disallow edits/deletes to keep audit trail simple
        allow update, delete: if false;
      }

      // Subcollection: per-user members state (unread, typing, lastReadAt)
      match /members/{memberId} {
        // Only the user can read/write their own member doc, and only if they are in the chat
        allow read: if isAuthenticated() && request.auth.uid == memberId && isChatMember(chatId);
        allow create, update: if isAuthenticated() && request.auth.uid == memberId && isChatMember(chatId)
          && (request.resource.data.unread == null || request.resource.data.unread is int)
          && (request.resource.data.lastReadAt == null || request.resource.data.lastReadAt is timestamp)
          && (request.resource.data.typing == null || request.resource.data.typing is bool);
        allow delete: if false;
      }
    }
  }
}
